# 综合评分与深度解析流程

本文说明「综合评分」和「深度分析」里**依赖按行解析/正则**的完整流程，以及为何格式波动会影响结果。

---

## 一、综合评分流程（单只标的）

### 1. 数据与 Prompt 组装

```
技术面(technical) + 消息面(news + 新闻摘要LLM) + 财报(fundamental + 财报解读LLM) + 期权(options)
    → _build_prompt(...) 拼成一大段 User Prompt
    → System: "你是多维度分析师，按 10 项格式输出，每行一项"
```

### 2. LLM 调用与期望输出格式

- **调用**：`llm.ask_llm(system=..., user=prompt)`，得到一段**纯文本** `raw`。
- **期望**：模型**严格按行**输出 10 行，每行形如：
  - `核心结论：xxx`
  - `趋势结构：xxx`
  - `MACD状态：xxx`
  - `KDJ状态：xxx`
  - `分析原因：xxx`
  - `评分：7`（仅数字）
  - `评分理由：xxx`
  - `交易动作：买入`（或 观察 / 离场）
  - `加仓价格：185.50`（或 —）
  - `减仓价格：170.00`（或 —）

### 3. 按行解析（_parse_llm_output）

- **位置**：`agents/full_analysis.py` 中 `_parse_llm_output(text)`。
- **做法**：
  - 用 `text.strip().split("\n")` 按**换行**拆成多行。
  - 对**每一行**用 `line.startswith("核心结论：")`、`line.startswith("评分：")` 等做**前缀匹配**。
  - 匹配到则用 `line.replace("核心结论：", "").strip()` 取冒号后面的内容，填入 `out["core_conclusion"]` 等。
- **评分**：对「评分：」那一行，用**正则** `re.sub(r"[^\d.]", "", ...)` 去掉非数字和小数点，再转 float，并 clamp 到 [1, 10]；解析失败则默认 5。
- **交易动作**：取「交易动作：」后的文字，再经 `_normalize_action()` 用关键词（买入/离场/观察等）归一为三选一。

### 4. 为何易受格式波动影响

| 情况 | 解析结果 |
|------|----------|
| 模型多输出一行「备注：…」或空行 | 一般不影响，因为只认固定前缀 |
| 模型写成了「核心结论:」（英文冒号） | `startswith("核心结论：")` 不匹配，该项为空 |
| 模型把两项写在一行，如「核心结论：xxx 趋势结构：yyy」 | 只匹配到第一项，趋势结构漏掉 |
| 模型输出「评分： 7」或「评分：7分」 | 正则 `[^\d.]` 可抽出 7，但「7分」可能被抽成 7，依赖实现 |
| 模型输出 markdown 如「**评分**：7」 | `startswith("评分：")` 不匹配，评分为默认 5 |
| 模型用「评分： 8.5」 | 可解析；若写「约 8」则正则可能得到 8 或空 |
| 换行符不一致（\r\n、多换行） | `split("\n")` 后可能多出空行或一行带 \r，通常仍能匹配前缀，但若模型用 \n 把「核心结论」和内容拆两行，则第二行没有「核心结论：」前缀，该项为空 |

**结论**：解析完全依赖「每行一个固定前缀 + 冒号后内容」；模型多写、少写、换格式（如英文冒号、markdown、多行一段）都会导致漏项或默认值。

---

## 二、深度分析里的「评分微调」解析流程

### 1. 何时触发

- 在**深度报告**（`deep=1`）下，单只标的先跑完 `run_full_analysis` 得到**综合评分**，再跑五类深度分析（①②③④⑤），然后根据五段摘要做**一次 LLM 微调**，得到最终评分。

### 2. 微调 LLM 的输入与期望输出

- **输入**：当前综合评分 + 五段深度摘要（每段截前约 200 字）。
- **Prompt 要求**：只输出**一行**，且**仅**以下两种格式之一：
  - `最终评分：N`（N 为 1～10 整数）
  - 或 `调整：+1` / `调整：0` / `调整：-1`

### 3. 正则解析（_adjust_score_by_deep）

- **位置**：`agents/report_deep.py` 中 `_adjust_score_by_deep()`。
- **做法**：
  - 先用正则 `re.search(r"最终评分[：:]\s*(\d+)", raw)` 匹配「最终评分：N」或「最终评分:N」。
  - 若匹配到，取 group(1) 转 int，clamp 到 [1,10] 作为最终分。
  - 若未匹配，再用 `re.search(r"调整[：:]\s*([+-]?\d+)", raw)` 匹配「调整：+1」等，取 group(1) 作为 delta，`原分 + delta` 再 clamp。
  - 若两个都没匹配到，返回 `None`，调用方保留原综合评分。

### 4. 为何易受格式波动影响

| 情况 | 解析结果 |
|------|----------|
| 模型输出「最终评分： 8」或「最终评分:8」 | 能匹配（正则允许中英文冒号和空格） |
| 模型输出「最终评分是 8」 | 正则不匹配，返回 None，保留原分 |
| 模型输出「我建议最终评分：8」 | 能匹配到「最终评分：8」这一段 |
| 模型多写了几句再写「调整：-1」 | 通常能匹配到 |
| 模型输出「调整： -1」或「调整:-1」 | 能匹配 |
| 模型输出「分数调整：-1」 | 不匹配「调整：」，返回 None |

**结论**：依赖「最终评分」/「调整」+ 冒号 + 数字的固定句式；换说法或加多余文字可能匹配失败，只能回退到原分。

---

## 三、流程串联总览

```
【综合评分】
  技术/消息/财报/期权 → 拼 Prompt → ask_llm → 得到 raw 文本
      → _parse_llm_output(raw)：按行 startswith("核心结论：") 等 + 评分行用正则提数字
      → 得到 core_conclusion, score, action, add_price, ... 等 10 项
      → 写入报告卡片

【深度报告时】
  run_full_analysis → 得到综合 score
  → 跑五链（①②③④⑤）→ deep_results
  → _adjust_score_by_deep(ticker, score, deep_results)
      → ask_llm(微调 Prompt) → raw
      → 正则匹配「最终评分：N」或「调整：±1」
      → 得到微调后分数或 None（保留原分）
  → 卡片用微调后分数（若有）否则用综合 score
```

---

## 四、改进方向（结构化输出）

- **综合评分**：用 LangChain 的 `with_structured_output(Pydantic)` 或 OpenAI 的 response_format 让模型直接返回 JSON，例如：
  - `{"core_conclusion": "...", "score": 7, "action": "观察", ...}`，不再按行前缀解析。
- **深度微调**：同样可定义为小 JSON，如 `{"final_score": 8}` 或 `{"adjustment": -1}`，一次解析即可，避免依赖「最终评分：」/「调整：」的固定句式。

这样模型只要输出合法 JSON，格式波动对解析的影响会小很多；校验与默认值可在 Pydantic 或后处理里统一处理。
